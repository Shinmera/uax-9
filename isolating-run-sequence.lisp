#|
 This file is a part of UAX-9
 (c) 2019 Shirakumo http://tymoon.eu (shinmera@tymoon.eu)
 Author: Nicolas Hafner <shinmera@tymoon.eu>
|#

(in-package #:org.shirakumo.alloy.uax-9)

(defstruct (seq (:constructor make-seq (indices types levels level sos eos))
                (:copier NIL))
  (indices NIL :type (simple-array idx (*)))
  (types NIL :type (simple-array (unsigned-byte 8) (*)))
  (levels NIL :type (simple-array (unsigned-byte 8) (*)))
  (level 0 :type (unsigned-byte 8))
  (sos 0 :type (unsigned-byte 8))
  (eos 0 :type (unsigned-byte 8)))

(defun make-isolating-run-sequence (indexes string paragraph-level result-types result-levels)
  (let ((types (make-array (length indexes) :element-type '(unsigned-byte 8))))
    (loop for i from 0 below (length indexes)
          do (setf (aref types i) (aref result-types (aref indexes i))))
    (let* ((level (aref result-levels (aref indexes 0)))
           (levels (make-array (length indexes) :element-type '(unsigned-byte 8) :initial-element level))
           (prev-char (1- (aref indexes 0))))
      (loop while (and (<= 0 prev-char) (removed-by-x9-p (class-at string prev-char)))
            do (decf prev-char))
      (let* ((prev-level (if (<= 0 prev-char)
                             (aref result-levels prev-char)
                             paragraph-level))
             (sos (type-for-level (max prev-level level)))
             (last-type (aref types (1- (length types))))
             (succ-level 0))
        (cond ((or (class= last-type :LRI)
                   (class= last-type :RLI)
                   (class= last-type :FSI))
               (setf succ-level paragraph-level))
              (T
               (let ((limit (1+ (aref indexes (1- (length indexes))))))
                 (loop while (and (< limit (length string))
                                  (removed-by-x9-p (class-at string limit)))
                       do (incf limit))
                 (setf succ-level (if (< limit (length string))
                                      (aref result-levels limit)
                                      paragraph-level)))))
        (let ((eos (type-for-level (max succ-level level))))
          (make-seq indexes types levels level sos eos))))))

(defun resolve-paired-brackets (seq string)
  (let ((indices (seq-indices seq))
        (sos (seq-sos seq))
        (dir (type-for-level (seq-level seq)))
        (types (seq-types seq))
        (openers ())
        (pair-positions ()))
    ;; locateBrackets
    (loop for i from 0 below (length indices)
          for type = (bracket-type-at string (aref indices i))
          do (when (and (/= type 0)
                        (class= (aref types i) :ON))
               (ecase type
                 ;; Open
                 (1 (when (= (length openers) MAX-PAIRING-DEPTH)
                      (setf openers ())
                      (return))
                  (push i openers))
                 ;; Close
                 (2 (when openers
                      (loop for cons on openers
                            for opener = (car cons)
                            do (when (or (= (code-at string (aref indices i))
                                            (bracket-sibling-at string (aref indices opener)))
                                         ;; Special handling for these
                                         (and (= (code-at string (aref indices i)) #x232A)
                                              (= (bracket-sibling-at string (aref indices opener)) #x3009))
                                         (and (= (code-at string (aref indices i)) #x3009)
                                              (= (bracket-sibling-at string (aref indices opener)) #x232A)))
                                 (push (cons opener i) pair-positions)
                                 (setf openers (cdr cons))
                                 (loop-finish))))))))
    (setf pair-positions (sort pair-positions #'< :key #'car))
    ;; resolveBrackets / assignBracketType
    (loop for pair in pair-positions
          for dir-pair = (classify-pair-content types pair dir)
          do (unless (class= dir-pair :ON)
               (when (/= dir-pair dir)
                 (setf dir-pair (class-before-pair types sos pair))
                 (when (or (= dir-pair dir) (class= dir-pair :ON))
                   (setf dir-pair dir))))
             (set-brackets-to-type string indices types pair dir-pair))))

(defun classify-pair-content (types pair dir-embed)
  (loop with opposite = (class-id :ON)
        for i from (1+ (car pair)) below (cdr pair)
        for dir = (normalize-strong-type-n0 (aref types i))
        do (unless (class= dir :ON)
             (when (= dir dir-embed)
               (return dir))
             (setf opposite dir))
        finally (return opposite)))

(defun class-before-pair (types sos pair)
  (loop for i downfrom (1- (car pair)) to 0
        for dir = (normalize-strong-type-n0 (aref types i))
        do (unless (class= dir :ON)
             (return dir))
        finally (return sos)))

(defun set-brackets-to-type (string indices types pair dir)
  (destructuring-bind (opener . closer) pair
    (setf (aref types opener) dir)
    (setf (aref types closer) dir)
    ;; Done twice just to skip the closer character... yeesh.
    (loop for i from (1+ opener) below closer
          for index = (aref indices i)
          do (if (class= (class-at string index) :NSM)
                 (setf (aref types i) dir)
                 (loop-finish)))
    (loop for i from (1+ closer) below (length indices)
          for index = (aref indices i)
          do (if (class= (class-at string index) :NSM)
                 (setf (aref types i) dir)
                 (loop-finish)))))

(declaim (ftype (function (seq idx idx function) idx) find-run-limit))
(defun find-run-limit (seq start end valid-p)
  (let ((types (seq-types seq)))
    (loop for i from start below end
          do (unless (funcall valid-p (aref types i))
               (return i))
          finally (return end))))

(defun resolve-weak-types (seq)
  (declare (optimize speed))
  ;; FIXME: it feels like a lot of these loops could be combined.
  (let ((types (seq-types seq)))
    ;; W1
    (loop with preceeding-type = (seq-sos seq)
          for i from 0 below (length types)
          for type = (aref types i)
          do (if (class= type :NSM)
                 (setf (aref types i) preceeding-type)
                 (setf preceeding-type type)))
    ;; W2
    (loop for i from 0 below (length types)
          do (when (class= (aref types i) :EN)
               (loop for j downfrom (1- i) to 0
                     for type = (aref types j)
                     do (when (or (class= type :L)
                                  (class= type :R)
                                  (class= type :AL))
                          (when (class= type :AL)
                            (setf (aref types i) (class-id :AN)))
                          (loop-finish)))))
    ;; W3
    (loop for i from 0 below (length types)
          do (when (class= (aref types i) :AL)
               (setf (aref types i) (class-id :R))))
    ;; W4 
    (loop for i from 1 below (1- (length types))
          for type = (aref types i)
          do (when (or (class= type :ES)
                       (class= type :CS))
               (let ((prev-sep (aref types (1- i)))
                     (succ-sep (aref types (1+ i))))
                 (cond ((and (class= prev-sep :EN)
                             (class= succ-sep :EN))
                        (setf (aref types i) (class-id :EN)))
                       ((and (class= type :CS)
                             (class= prev-sep :AN)
                             (class= succ-sep :AN))
                        (setf (aref types i) (class-id :AN)))))))
    ;; W5
    (loop for i from 0 below (length types)
          do (when (class= (aref types i) :ET)
               (let* ((run-start i)
                      (run-limit (find-run-limit seq run-start (length types) (lambda (x) (class= (the class x) :ET))))
                      (type (if (= 0 run-start) (seq-sos seq) (aref types (1- run-start)))))
                 (unless (class= type :EN)
                   (setf type (if (= run-limit (length types)) (seq-eos seq) (aref types run-limit))))
                 (when (class= type :EN)
                   (loop for i from run-start below run-limit
                         do (setf (aref types i) (class-id :EN))))
                 (setf i run-limit))))
    ;; W6/W7
    (loop for i from 0 below (length types)
          for type = (aref types i)
          do (cond ;; W6
               ((or (class= type :ES)
                    (class= type :ET)
                    (class= type :CS))
                (setf (aref types i) (class-id :ON)))
               ;; W7
               ((class= (aref types i) :EN)
                (let ((prev-strong-type (seq-sos seq)))
                  (loop for j downfrom (1- i) to 0
                        for type = (aref types j)
                        do (when (or (class= type :L)
                                     (class= type :R))
                             (setf prev-strong-type type)
                             (loop-finish)))
                  (when (class= prev-strong-type :L)
                    (setf (aref types i) (class-id :L)))))))))

(defun resolve-neutral-types (seq)
  (let ((types (seq-types seq)))
    (loop for i from 0 below (length types)
          for type = (aref types i)
          do (when (neutral-type-p type)
               (let* ((run-start i)
                      (run-limit (find-run-limit seq run-start (length types) #'neutral-type-p))
                      leading-type trailing-type)
                 (cond ((= 0 run-start)
                        (setf leading-type (seq-sos seq)))
                       (T
                        (setf leading-type (aref types (1- run-start)))
                        (when (or (class= leading-type :AN)
                                  (class= leading-type :EN))
                          (setf leading-type (class-id :R)))))
                 (cond ((= run-limit (length types))
                        (setf trailing-type (seq-eos seq)))
                       (T
                        (setf trailing-type (aref types run-limit))
                        (when (or (class= trailing-type :AN)
                                  (class= trailing-type :EN))
                          (setf trailing-type (class-id :R)))))
                 (let ((resolved-type (if (= leading-type trailing-type)
                                          leading-type
                                          (type-for-level (seq-level seq)))))
                   (loop for i from run-start below run-limit
                         do (setf (aref types i) resolved-type))
                   (setf i run-limit)))))))

(defun resolve-implicit-levels (seq)
  (let* ((types (seq-types seq))
         (levels (seq-levels seq)))
    (cond ((evenp (seq-level seq))
           (loop for i from 0 below (length types)
                 for type = (aref types i)
                 do (cond ((class= type :R)
                           (incf (aref levels i) 1))
                          ((or (class= type :EN)
                               (class= type :AN))
                           (incf (aref levels i) 2)))))
          (T
           (loop for i from 0 below (length types)
                 for type = (aref types i)
                 do (when (or (class= type :L)
                              (class= type :EN)
                              (class= type :AN))
                      (incf (aref levels i) 1)))))))

(defun apply-levels-and-types (seq result-types result-levels)
  (let ((indices (seq-indices seq))
        (types (seq-types seq))
        (levels (seq-levels seq)))
    (loop for i from 0 below (length types)
          for original-index = (aref indices i)
          do (setf (aref result-types original-index) (aref types i))
             (setf (aref result-levels original-index) (aref levels i)))))
